package org.purnamaproject.xui.impl;

/**
 * @(#)XUITable.java    0.5 18/08/2003
 *
 * The Purnama Project XUI (XML-based User Interface) API is an set of program
 * calls that utilize the XUI tagset and perform the task of creating a user
 * interface. The Purnama version of this API is specific using Java as the platform
 * but other XUI APIs may use other libraries and platforms. The Purnama XUI API
 * supports the creation of Swing components, adding, deleting and laying out
 * components. It also supports dynamic binding of business logic to the user
 * interface.
 *
 * Copyright (c) 2003 Arron Ferguson
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * For more information, please contact Arron Ferguson at:
 * e-mail: arron_ferguson@bcit.ca
 * snail-mail: SW2 - 124, 3700 Willingdon Avenue, Burnaby, British Columbia, Canada, V5G 3H2
 * Web: http://xml.bcit.ca/PurnamaProject/
 *
 */

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.Rectangle;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Vector;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JTable;
import javax.swing.SwingConstants;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;
import javax.swing.table.TableModel;
import org.purnamaproject.xui.helpers.IDFactory;
import org.purnamaproject.xui.helpers.XUIUtils;
import org.purnamaproject.xui.binding.XUIModel;
import org.purnamaproject.xui.binding.XUITableModel;
import org.purnamaproject.xui.component.atomic.XUITable;
import org.purnamaproject.xui.component.XUIComponent;
import org.purnamaproject.xui.component.container.intermediate.XUIPanel;
import org.purnamaproject.xui.impl.XUINodeImpl;
import org.purnamaproject.xui.XUIDisplayException;
import org.purnamaproject.xui.XUINode;
import org.purnamaproject.xui.XUITypeFormatException;
import org.purnamaproject.xui.peer.JScrollTable;
import org.purnamaproject.xui.peer.RowHeaderRenderer;

/**
 * This atomic component represents a table consisting of columns and rows. It allows for
 * the user to change values in each cell of the table. Listeners will be informed of any
 * changes made in each cell.
 *
 * @version 0.5 18/08/2003
 * @author  Arron Ferguson
 */
public class XUITableImpl implements XUITable, MouseListener, TableModelListener
{
    /**
     * The label representation of this component.
     */
    private JScrollTable scrollTable;

    /**
     * The table that sits within the scroll table.
     */
    private JTable table;

    /**
     * The node representation of this component.
     */
    private XUINode tableNode;

    /**
     * The grid width of this component (in grid cells).
     */
    private int gridWidth = 1;

    /**
     * The grid height of this component (in grid cells).
     */
    private int gridHeight = 1;

    /**
     * The grid x coordinate of this component (within the grid).
     */
    private int gridX = 0;

    /**
     * The grid y coordinate of this component (within the grid).
     */
    private int gridY = 0;

    /**
     * The list of model objects that are ready to be listeners to any events generated by this
     * component.
     */
    private List tableModelList = new LinkedList();

    /**
     * <p>Constructs a new XUITable implementation and passing it its XML node rather than requiring
     * the XUITable implementation to build it from scratch. This method is called by the Realizer
     * when it reads the XML document from the file system.</p>
     *
     * <p><b><u>Note:</u></b> This constructor is not normally something that should be called up.
     * This constructor is required when creating a XUI Table where the node has already been built
     * by the realizer or a subclass thereof.</p>
     *
     * <p><b><u>Note:</u></b> Schema checking is assumed at this point. Any node passed to this method
     * will be assumed to have passed through the schema validator.</p>
     *
     * @see #setComponentSize(int, int)
     * @see #setComponentLocation(int, int)
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param node the new node representing this GUI component.
     */
    public XUITableImpl(XUINode node) throws XUIDisplayException
    {
        gridX = Integer.parseInt(node.getAttributeValue("x"));
        gridY = Integer.parseInt(node.getAttributeValue("y"));
        gridWidth = Integer.parseInt(node.getAttributeValue("width"));
        gridHeight = Integer.parseInt(node.getAttributeValue("height"));

        if(!(node.getName().equals("Table")))
            throw new XUIDisplayException("Node for XUITable must be named 'Table' and conform to the XUI schema.");
        else
        {
            int rowLength = 0;
            int columnHeaderLength = 0;
            int rowHeaderLength = 0;
            int columnCount = 0;
            int rowCount = 0;

            tableNode = node;



            // get column header values
            boolean haveColumns = false;
            List columnHeader = node.getChildNodesByName("ColumnHeader");
            if(columnHeader.size() > 0)
            {
                XUINode columnHeaderNode = (XUINode)columnHeader.get(0);
                List columnHeaderCells = columnHeaderNode.getChildNodesByName("Cell");
                Vector columnHeadersList = new Vector();

                for(int i = 0; i < columnHeaderCells.size(); i++)
                {
                    XUINode headerCell = (XUINode)columnHeaderCells.get(i);
                    columnHeadersList.add(headerCell.getCDATA());
                }
                columnHeaderLength = columnHeadersList.size();
                columnCount = columnHeaderLength;
                haveColumns = true;
            }


            // get row header values
            List rowHeader = node.getChildNodesByName("RowHeader");
            Vector rowHeadersList = null;
            boolean haveRows = false;
            if(rowHeader.size() > 0)
            {
                XUINode rowHeaderNode = (XUINode)rowHeader.get(0);
                List rowHeaderCells = rowHeaderNode.getChildNodesByName("Cell");
                rowHeadersList = new Vector();

                for(int i = 0; i < rowHeaderCells.size(); i++)
                {
                    XUINode rowCell = (XUINode)rowHeaderCells.get(i);
                    rowHeadersList.add(rowCell.getCDATA());
                }
                haveRows = true;
                rowHeaderLength = rowHeadersList.size();
            }

            // get row values
            List rowNodes = node.getChildNodesByName("Row");
            rowCount = rowNodes.size();

            if(haveRows)
                if(rowCount != rowHeaderLength)
                    throw new XUIDisplayException("Must have the same number of row headers as rows.");

            Vector rows = new Vector();

            for(int x = 0; x < rowNodes.size(); x++)
            {
                Vector aRow = new Vector();

                XUINode rowNode = (XUINode)rowNodes.get(x);
                List cellNodes = rowNode.getChildNodesByName("Cell");

                for(int y = 0; y < cellNodes.size(); y++)
                {
                    XUINode cellNode = (XUINode)cellNodes.get(y);
                    aRow.add(cellNode.getCDATA());
                }
                rowLength = aRow.size();

                if(haveColumns)
                    if(rowLength != columnHeaderLength)
                        throw new XUIDisplayException("Must have the same number of columns for rows and headers.");

                rows.add(aRow);
            }

            // gui component
            scrollTable = new JScrollTable(rowCount, columnCount,
                Boolean.valueOf(node.getAttributeValue("isEditable")).booleanValue());
            table = scrollTable.getTable();
            if(rowHeaderLength > 0)
            {
                JList customRowHeader = new JList(rowHeadersList);
// commented out because it causes redraw problems. Not my fault.
//              customRowHeader.setPreferredSize(new Dimension(50, 30));
                customRowHeader.setCellRenderer(new RowHeaderRenderer(table));
                scrollTable.getScrollPane().setRowHeaderView(customRowHeader);
            }

            // now set alignment
            setAlignment(node);

            tableNode.setXUIComponent(this);
        }

    }

    /**
     * Creates a table. Default size is 1 x 1 cells in the top left corner of the container with no initial
     * rows or header (thus, it will not display cells). Alignment is left by default. Editability is default.
     */
    public XUITableImpl()
    {
        // create the XML node representing this component.
        tableNode = new XUINodeImpl("Table");
        tableNode.setLevel(3);
        tableNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
        tableNode.setXUIComponent(this);

        // gui component
        scrollTable = new JScrollTable();
        table = scrollTable.getTable();


        // add specific attributes
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "id", "id", "xs:ID",
            IDFactory.getInstance().generateID("table"));
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "x", "x", "xs:unsignedShort",
            "0");
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "y", "y", "xs:unsignedShort",
            "0");
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "width", "width", "xs:unsignedShort",
            "1");
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "height", "height", "xs:unsignedShort",
            "1");
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "isEditable", "isEditable",
            "xs:boolean", "false");

    }

    /**
     * Creates a table and gives it x and y coordinates. If the table has a parent,
     * then the table will be placed at that position. The x and y values must be within the XUI
     * schema specification as well, be placed on the panel and not overtop of any other component.
     * If so, an exception is generated.
     *
     * @see #setComponentLocation(int, int)
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param xCoordinate the x coordinate used to place the button on the grid.
     * @param yCoordinate the y coordinate used to place the button on the grid.
     */
    public XUITableImpl(int xCoordinate, int yCoordinate) throws XUIDisplayException
    {
        if(xCoordinate < 0 || xCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        if(yCoordinate < 0 || yCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        else
        {

            // create the XML node representing this component.
            tableNode = new XUINodeImpl("Table");
            tableNode.setLevel(3);
            tableNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
            tableNode.setXUIComponent(this);

            // gui component
            scrollTable = new JScrollTable();
            table = scrollTable.getTable();


            // add specific attributes
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "id", "id", "xs:ID",
                IDFactory.getInstance().generateID("table"));
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "width", "width", "xs:unsignedShort",
                "1");
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "height", "height", "xs:unsignedShort",
                "1");
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "isEditable", "isEditable",
                "xs:boolean", "false");

            gridX = xCoordinate;
            gridY = yCoordinate;
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "x", "x", "xs:unsignedShort",
                String.valueOf(xCoordinate));
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "y", "y", "xs:unsignedShort",
                String.valueOf(yCoordinate));
        }
    }

    /**
     * Creates a table and gives it x and y coordinates and sets cell editability. If the table has a parent,
     * then the table will be placed at that position. The x and y values must be within the XUI
     * schema specification as well, be placed on the panel and not overtop of any other component.
     * If so, an exception is generated.
     *
     * @see #setComponentLocation(int, int)
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param xCoordinate the x coordinate used to place the button on the grid.
     * @param yCoordinate the y coordinate used to place the button on the grid.
     * @param isEditable whether or not the cells are editable.
     */
    public XUITableImpl(boolean isEditable, int xCoordinate, int yCoordinate) throws XUIDisplayException
    {
        if(xCoordinate < 0 || xCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        if(yCoordinate < 0 || yCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        else
        {

            // create the XML node representing this component.
            tableNode = new XUINodeImpl("Table");
            tableNode.setLevel(3);
            tableNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
            tableNode.setXUIComponent(this);

            // gui component
            scrollTable = new JScrollTable(isEditable);
            table = scrollTable.getTable();


            // add specific attributes
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "id", "id", "xs:ID",
                IDFactory.getInstance().generateID("table"));
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "width", "width", "xs:unsignedShort",
                "1");
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "height", "height", "xs:unsignedShort",
                "1");
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "isEditable", "isEditable",
                "xs:boolean", "false");

            gridX = xCoordinate;
            gridY = yCoordinate;
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "x", "x", "xs:unsignedShort",
                String.valueOf(xCoordinate));
            tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "y", "y", "xs:unsignedShort",
                String.valueOf(yCoordinate));
        }
    }

    /**
     * Creates a table and gives it x and y coordinates with a specificed alignment. The alignment
     * is either left, right or justified. If the table has a parent, then the table will be placed at
     * that position. The x and y values must be within the XUI schema specification as well, be placed
     * on the panel and not overtop of any other component. If so, an exception is generated.
     *
     * @see #setComponentLocation(int, int)
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param xCoordinate the x coordinate used to place the button on the grid.
     * @param yCoordinate the y coordinate used to place the button on the grid.
     * @param alignment the alignment (must be either XUIUtils.LEFT_JUSTIFIED, XUIUtils.RIGHT_JUSTIFIED
     * or XUIUtils.CENTER_JUSTIFIED. If none of those three, an exception is generated.
     */
    public XUITableImpl(int xCoordinate, int yCoordinate, int alignment) throws XUIDisplayException
    {
        this(xCoordinate, yCoordinate);
        if(alignment != XUIUtils.LEFT_JUSTIFIED || alignment != XUIUtils.RIGHT_JUSTIFIED
            || alignment != XUIUtils.CENTER_JUSTIFIED)
            throw new XUIDisplayException("Alignment must be either left, right or justified.");
        else
        {
            int align = alignment;

            // columns first
            int columns = table.getColumnCount();
            for(int i = 0; i < columns; i++)
            {
                JLabel headerRenderer = (JLabel)table.getColumnModel().getColumn(i).getHeaderRenderer();
                headerRenderer.setHorizontalAlignment(align);
            }

            // cells
            int rows = table.getRowCount();
            for(int r = 0; r < columns; r++)
            {
                for(int c = 0; c < rows; c++)
                {
                    JLabel cellRenderer = (JLabel)table.getCellRenderer(r, c);
                    cellRenderer.setHorizontalAlignment(align);
                }
            }

        }
    }

    /**
     * Sets the alignment of all cells within the table. Does this based on the Cell node's 'justified'
     * attribute.
     *
     * @param node the node representing this component.
     */
    private void setAlignment(XUINode node)
    {

        // do header alignment
        List header = node.getChildNodesByName("ColumnHeader");
        if(header.size() > 0)
        {
            XUINode headerNode = (XUINode)header.get(0);
            List headerCells = headerNode.getChildNodesByName("Cell");
            Vector headersList = new Vector();

            for(int i = 0; i < headerCells.size(); i++)
            {
                JLabel renderer = (JLabel)table.getTableHeader().getDefaultRenderer();

                XUINode headerCell = (XUINode)headerCells.get(i);
                if(headerCell.getAttributeValue("justified").equals("left"))
                    renderer.setHorizontalAlignment(JLabel.LEFT);
                else if(headerCell.getAttributeValue("justified").equals("right"))
                    renderer.setHorizontalAlignment(JLabel.RIGHT);
                else if(headerCell.getAttributeValue("justified").equals("center"))
                    renderer.setHorizontalAlignment(JLabel.CENTER);

            }
        }

        // do row alignment
        List rowNodes = node.getChildNodesByName("Row");
        int numberOfRows = rowNodes.size();

        for(int x = 0; x < numberOfRows; x++)
        {
            // get the row node.
            XUINode rowNode = (XUINode)rowNodes.get(x);

            // get the list of cells within a row (XUINode type)
            List cellNodes = rowNode.getChildNodesByName("Cell");
            int numberOfCells = cellNodes.size();

            for(int y = 0; y < numberOfCells; y++)
            {
                // get the cell node
                XUINode cellNode = (XUINode)cellNodes.get(y);

                JLabel renderer = (JLabel)table.getCellRenderer(x, y);

                if(cellNode.getAttributeValue("justified").equals("left"))
                    renderer.setHorizontalAlignment(JLabel.LEFT);
                else if(cellNode.getAttributeValue("justified").equals("right"))
                    renderer.setHorizontalAlignment(JLabel.RIGHT);
                else if(cellNode.getAttributeValue("justified").equals("center"))
                    renderer.setHorizontalAlignment(JLabel.CENTER);

            }


        }

    }

    /**
     * Sets the alignment of a particular cell.
     *
     * @param rowIndex the row to index.
     * @param columnIndex the column to index.
     * @param alignment the alignment ('left', 'right', 'center').
     */
    private void setCellAlignment(int rowIndex, int columnIndex, String alignment)
    {
        // get a particular row
        List rowNodes = tableNode.getChildNodesByName("Row");
        XUINode row = (XUINode)rowNodes.get(rowIndex);

        // based on the particular row, get a particular cell.
        List cellNodes = row.getChildNodesByName("Cell");
        XUINode cell = (XUINode)cellNodes.get(columnIndex);
        cell.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "justified", "justified",
            "xs:token", alignment);
    }

    /**
     * <p>Passes the new coordinates and width and height for the dimensions.</p>
     *
     * <p><b>Note:</b> <i>This method call should never be called by any class other than
     * the <code>org.purnamaproject.xui.helpers.ComponentFactory</code> as it is assumed that
     * the XUI document will be created via the API calls rather than through unmarshalling
     * of the XUI document. These two pipelines are treated separately in their handling of
     * Only implementors of the ComponentFactory class should call this method.</i><p>
     *
     * @param x the x coordinate of this component and where to place it within the container
     * that it sits within.
     * @param y the y coordinate of this component and where to place it within the container
     * that it sits within.
     * @param width the width dimension of this component and the size to make it within the container
     * that it sits within.
     * @param height the height dimension of this component and the size to make it within the container
     * that it sits within.
     */
    public void factoryCoordinates(int x, int y, int width, int height)
    {
        gridX = x;
        gridY = y;
        gridWidth = width;
        gridHeight = height;
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "x", "x", "xs:unsignedShort",
            "" + x);
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "y", "y", "xs:unsignedShort",
            "" + y);
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "width", "width", "xs:unsignedShort",
            "" + width);
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "height", "height", "xs:unsignedShort",
            "" + height);
    }

    /**
     * Allows a specific cell to have its alignment changed (e.g. justified left).
     *
     * @param rowIndex the row index.
     * @param columnIndex the column index.
     * @param alignment the alignment attribute. The three options are XUIUtils.LEFT_JUSTIFIED,
     * XUIUtils.RIGHT_JUSTIFIED and XUIUtils.CENTER_JUSTIFIED
     */
    public void setCellAlignment(int rowIndex, int columnIndex, int alignment)
    {
        JLabel renderer = (JLabel)table.getCellRenderer(rowIndex, columnIndex);
        if(alignment == XUIUtils.LEFT_JUSTIFIED)
        {
            renderer.setHorizontalAlignment(JLabel.LEFT);
            setCellAlignment(rowIndex, columnIndex, "left");
        }
        else if(alignment == XUIUtils.RIGHT_JUSTIFIED)
        {
            renderer.setHorizontalAlignment(JLabel.RIGHT);
            setCellAlignment(rowIndex, columnIndex, "right");
        }
        else if(alignment == XUIUtils.CENTER_JUSTIFIED)
        {
            renderer.setHorizontalAlignment(JLabel.CENTER);
            setCellAlignment(rowIndex, columnIndex, "center");
        }
    }

    /**
     * Returns the x coordinate of this component. For a top level container, this coordinate is the actual
     * x coordinate value (in pixels) that appears on the desktop. For an intermediate component, this x
     * coordinate is the position within the layout grid that is assigned to the top level container.
     *
     * @return the x coordinate of this component.
     */
    public int getX()
    {
        return gridX;
    }

    /**
     * Returns the y coordinate of this component. For a top level container, this coordinate is the actual
     * y coordinate value (in pixels) that appears on the desktop. For an intermediate component, this y
     * coordinate is the position within the layout grid that is assigned to the top level container.
     *
     * @return the y coordinate of this component.
     */
    public int getY()
    {
        return gridY;
    }

    /**
     * Returns the width of this component. For a top level container, this value is the actual width
     * (in pixels) that appears on the desktop. For an intermediate component, this width value is the
     * position within the layout grid that is assigned to the top level container (e.g. 2 would be two
     * cells wide.
     *
     * @return the width of this component.
     */
    public int getWidth()
    {
        return gridWidth;
    }

    /**
     * Returns the height of this component. For a top level container, this value is the actual height
     * (in pixels) that appears on the desktop. For an intermediate component, this height value is the
     * position within the layout grid that is assigned to the top level container (e.g. 2 would be two
     * cells high.
     *
     * @return the height of this component.
     */
    public int getHeight()
    {
        return gridHeight;
    }

    /**
     * Sets this component to being enabled. By being enabled, it will respond to user operations.
     *
     * @param enabled true means this component is enabled and will respond to user operations and false
     * means that it will not.
     */
    public void setEnabled(boolean enabled)
    {
        scrollTable.setEnabled(enabled);
        tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "enabled", "enabled", "xs:boolean",
            "" + enabled);
    }

    /**
     * Returns the XUI id of this component.
     *
     * @return the id of this component as a string.

     */
    public String getID()
    {
        return tableNode.getAttributeID();
    }

    /**
     * Represents the XUI window component as a XUI node.
     *
     * @return org.purnamaproject.xui.XUINode the XML element as a XUI node.
     */
    public XUINode getNodeRepresentation()
    {
        return tableNode;
    }

    /**
     * This method returns the peer within the host operating system and user interface environment.
     * For each environment, this will return a different object type and may not be represented as
     * a class called component.
     *
     * @return Component which is the native representation of the GUI component.
     */
    public Component getPeer()
    {
        return scrollTable;
    }

    /**
     * <p>Sets the location of this component using x and y coordinates. This value will be different for top-level
     * containers as compared to intermediate level containers and atomic and composite components. For example,
     * for intermediate level containers, atomic components and composite components, the x and y coordinate
     * is the position within the layout grid. The x and y values must fall within the XUI schema limits
     * (0 to 65,655) as well as within the limits of the layout.</p>
     *
     * <p>If the integer number does not fall within the number 0 to 65,535, then a <code>XUIDisplayException</code>
     * is thrown and no change is made. If the integer number falls within this schema limit but outside of the
     * range of the grid, (i.e. grid is 5 x 5 but the value given starts at coordinate 8), then no update to the
     * layout is made (i.e. the component is not added to the layout.)</p>
     *
     * <p>If the coordinate values fall within the xml schema limits and falls within the grid range but another
     * component is currently inhabiting that area on the grid, then a <code>XUIDisplayException</code> is
     * thrown and no change is made (i.e. the component is not added to the layout.)</p>
     *
     * <p>If the component is a top-level container, then the x and y coordinate values refer to the screen
     * coordinates on the screen. The same rules apply to adhering to the integer range constraint. If the
     * top-level container is placed outside of the screen resolution of the host system, then a
     * <code>XUIDisplayException</code> is thrown and no change is made.</p>
     *
     * @see <a href="http://www.w3c.org/TR/xmlschema-2/#unsignedShort">W3C XML Schema, section 3.3.23</a>
     * @see <a href="http://geekkit.bcit.ca/xui/docs/specification/xuiSpecification0.5.0.html">Purnama Project XUI Specification</a>
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param yCoordinate the y coordinate.
     * @param xCoordinate the x coordinate.
     */
    public void setComponentLocation(int xCoordinate, int yCoordinate) throws XUIDisplayException
    {
        if(xCoordinate < 0 || xCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        if(yCoordinate < 0 || yCoordinate > 65535)
            throw new XUIDisplayException("x and y values must be within the range of 0 - 65535.");
        else
        {

            Container container = null;
            XUIPanel parent = null;

            XUINode parentNode = tableNode.getParent();
            if(parentNode != null)
                parent = (XUIPanel)parentNode.getXUIComponent();

            // proposed space to occupy
            Rectangle spaceToOccupy = new Rectangle(yCoordinate, xCoordinate, gridWidth, gridHeight);

            if(parent != null)
            {

                // collision detection
                Hashtable grid = parent.getGridMapping();

                Enumeration keys = grid.keys();

                container = (Container)parent.getPeer();

                // need to check if the space is occupied AND if that space if occupied by
                // someone OTHER than the current proposed component
                while(keys.hasMoreElements())
                {
                    XUIComponent someComponent = (XUIComponent)keys.nextElement();
                    Rectangle region = (Rectangle)grid.get(someComponent);
                    if(region.intersects(spaceToOccupy) && someComponent != this)
                        throw new XUIDisplayException("Component:\n" + someComponent + "\nis already in the area x: "
                            + yCoordinate + ", y: " + xCoordinate + ", width: " + gridWidth + ", height: "
                            + gridHeight);
                }

                // now check if the atomic falls within the grid as specified by the container.
                Dimension d = parent.getGrid();
                if(yCoordinate < 0 || (yCoordinate + gridWidth) > (d.getWidth()))
                    throw new XUIDisplayException("x & y coordinates must fall within the grid layout of the container.");
                else if(xCoordinate < 0 || (xCoordinate + gridHeight) > (d.getHeight()))
                    throw new XUIDisplayException("x & y coordinates must fall within the grid layout of the container.");
                else
                {
                    gridX = xCoordinate;
                    gridY = yCoordinate;
                    container.remove(scrollTable);
                    container.add(scrollTable, new Rectangle(gridY, gridX, gridWidth, gridHeight));
                    scrollTable.invalidate();
                    container.validate();

                    tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "x", "x", "xs:unsignedShort",
                        String.valueOf(xCoordinate));
                    tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "y", "y", "xs:unsignedShort",
                        String.valueOf(yCoordinate));
                }
            }

        }
    }

    /**
     * <p>Sets the size of this component using width and height integers. This value will be different for top-level
     * containers as compared to intermediate level containers and atomic and composite components. For example,
     * for intermediate level containers, atomic components and composite components, the width and height integers
     * are the size in cells within the layout grid. The width and height values must fall within the XUI schema
     * limits (0 to 65,655) as well as within the limits of the layout.</p>
     *
     * <p>If the integer number does not fall within the number 0 to 65,535, then a <code>XUIDisplayException</code>
     * is thrown and no change is made. If the integer number falls within this schema limit but outside of the
     * range of the grid, (i.e. grid is 5 x 5 but the value given for width is 8), then no update to the
     * layout is made (i.e. the component is not added to the layout.)</p>
     *
     * <p>If the dimension values falls within the xml schema limits and falls within the grid range but another
     * component is currently inhabiting that area on the grid, then a <code>XUIDisplayException</code> is
     * thrown and no change is made (i.e. the component is not added to the layout.)</p>
     *
     * <p>If the component is a top-level container, then the width and height values refer to the size in pixels
     * instead of grid cells. The same rules apply to adhering to the integer range constraint. If the
     * top-level container is wider or taller than the screen resolution of the host system, then a
     * <code>XUIDisplayException</code> is thrown and no change is made.</p>
     *
     * @see <a href="http://www.w3c.org/TR/xmlschema-2/#unsignedShort">W3C XML Schema, section 3.3.23</a>
     * @see <a href="http://geekkit.bcit.ca/xui/docs/specification/xuiSpecification0.5.0.html">Purnama Project XUI Specification</a>
     * @throws org.purnamaproject.xui.XUIDisplayException if the component is being placed overtop of an existing component on the
     * layout.
     * @param width the width of the component.
     * @param height the height of the component.
     */
    public void setComponentSize(int width, int height) throws XUIDisplayException
    {
        if(width < 0 || width > 65535)
            throw new XUIDisplayException("width and height values must be within the range of 0 - 65535.");
        if(height < 0 || height > 65535)
            throw new XUIDisplayException("width and height values must be within the range of 0 - 65535.");
        else
        {

            Container container = null;
            XUIPanel parent = null;

            XUINode parentNode = tableNode.getParent();
            if(parentNode != null)
                parent = (XUIPanel)parentNode.getXUIComponent();

            // proposed space to occupy
            Rectangle spaceToOccupy = new Rectangle(gridY, gridX, width, height);

            if(parent != null)
            {

                // collision detection
                Hashtable grid = parent.getGridMapping();

                Enumeration keys = grid.keys();

                container = (Container)parent.getPeer();

                // need to check if the space is occupied AND if that space if occupied by
                // someone OTHER than the current proposed component
                while(keys.hasMoreElements())
                {
                    XUIComponent someComponent = (XUIComponent)keys.nextElement();
                    Rectangle region = (Rectangle)grid.get(someComponent);
                    if(region.intersects(spaceToOccupy) && someComponent != this)
                        throw new XUIDisplayException("Component:\n" + someComponent + "\nis already in the area x: "
                            + gridY + ", y: " + gridX + ", width: " + width + ", height: "
                            + height);
                }

                // now check if the atomic falls within the grid as specified by the container.
                Dimension d = parent.getGrid();
                if(width < 0 || (gridY + width) > (d.getWidth()))
                    throw new XUIDisplayException("x & y coordinates must fall within the grid layout of the container.");
                else if(height < 0 || (gridX + height) > (d.getHeight()))
                    throw new XUIDisplayException("x & y coordinates must fall within the grid layout of the container.");
                else
                {
                    gridWidth = width;
                    gridHeight = height;
                    container.remove(scrollTable);
                    container.add(scrollTable, new Rectangle(gridY, gridX, gridWidth, gridHeight));
                    scrollTable.invalidate();
                    container.validate();

                    tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "width", "width", "xs:unsignedShort",
                        String.valueOf(width));
                    tableNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "height", "height", "xs:unsignedShort",
                        String.valueOf(height));
                }
            }

        }
    }

    /**
     * Returns the number of rows (excluding the header).
     *
     * @return the number of rows.
     * @see #getColumnCount()
     */
    public int getRowCount()
    {
        return table.getRowCount();
    }

    /**
     * Returns the number of columns.
     *
     * @return the number of columns.

     */
    public int getColumnCount()
    {
        return table.getColumnCount();
    }

    /**
     * Sets a value at the particular cell specificed. The values for rowIndex and columnIndex must fall within the
     * specified range of 0 to 65,535 as well, the row and column indexes must fall within the range of current
     * limits. If not an exception is generated. If the string value is null, an exception is generated.
     *
     * @param value the actual value to set to.
     * @param columnIndex the column index.
     * @param rowIndex the row index.
     * @see <a href="http://www.w3c.org/TR/xmlschema-2/#unsignedShort">W3C XML Schema, section 3.3.23</a>
     * @see <a href="http://geekkit.bcit.ca/xui/docs/specification/xuiSpecification0.5.0.html">Purnama Project XUI Specification</a>
     * @throws org.purnamaproject.xui.XUITypeFormatException if the type does not conform to the W3C XML Schema unsignedshort type or
     * if the string is null.
     */
    public void editCellValue(String value, int rowIndex, int columnIndex) throws XUITypeFormatException
    {
        if(value == null)
            throw new XUITypeFormatException("String value must not be null.");
        else
        {
            table.setValueAt(value, rowIndex, columnIndex);

            // get a particular row
            List rowNodes = tableNode.getChildNodesByName("Row");
            XUINode row = (XUINode)rowNodes.get(rowIndex);

            // based on the particular row, get a particular cell.
            List cellNodes = row.getChildNodesByName("Cell");
            XUINode cell = (XUINode)cellNodes.get(columnIndex);
            cell.setCDATA(value);

        }
    }

    /**
     * Returns the textual value at a particular cell.
     *
     * @return the textual value at row, column.
     * @see #editCellValue(String, int, int)
     */
    public String getCellValue(int row, int column)
    {
        return (String)table.getValueAt(row, column);
    }

    /**
     * <p>Sets the table data as a 2 dimensional list (list of lists). The list given is a two dimensional
     * collection (i.e. a list of lists) where each list within this current list is a row of data.
     * all lists must be of the same length and must not contain null values in them. An example of this
     * would be:</p>
     * <pre><code>
     * Vector list = new Vector();
     * Vector row1 = new Vector();
     * row1.add("123");
     * row1.add("456");
     * row1.add("789");
     * Vector row2 = new Vector();
     * row2.add("abc");
     * row2.add("def");
     * row2.add("ghi");
     * list.add(row1);
     * list.add(row2);
     * </pre></code>
     *
     * <p>The above creates a table that is 2 rows and 3 columns.</p>
     *
     * @param data the 2 dimensional list (list of lists) that contain string data in it.
     * @param headers the headers that are placed at the tops of the columns.
     * @throws org.purnamaproject.xui.XUITypeFormatException if any of the lists are null, if any of the strings are null, if
     * any of the lists are not the same size as specified row and column size as what was specified
     * for this table.
     */
    public void setTableData(Vector data, Vector headers) throws XUITypeFormatException
    {
        if(data == null)
            throw new XUITypeFormatException("The data list must not be null.");
        else if(data.size() == 0)
            throw new XUITypeFormatException("The data list contain other Vectors.");
        if(headers == null)
            throw new XUITypeFormatException("The data list must not be null.");
        else if(headers.size() != data.size())
            throw new XUITypeFormatException("The header list must be the same size as the data list.");
        else
        {
            DefaultTableModel model = (DefaultTableModel)table.getModel();
            try
            {
                model.setDataVector(data, headers);
                table.invalidate();
                if(table.getParent() != null)
                    table.getParent().validate();

                // add the headers
                XUINode headerNode = new XUINodeImpl("ColumnHeader");
                headerNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                int level = tableNode.getLevel();
                level += 1;
                headerNode.setLevel(level);
                level += 1;
                for(int h = 0; h < headers.size(); h++)
                {
                    XUINode cellNode = new XUINodeImpl("Cell");
                    cellNode.setLevel(level);
                    cellNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                    cellNode.setCDATA((String)headers.get(h));
                    headerNode.addChildNode(cellNode);
                }
                tableNode.addChildNode(headerNode);

                // set the level for the rows
                level -= 1;
                int cellLevel = level + 1;

                // now the data cells
                for(int r = 0; r < data.size(); r++)
                {
                    // new row
                    XUINode rowNode = new XUINodeImpl("Row");
                    rowNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                    rowNode.setLevel(level);
                    Vector row = (Vector)data.get(r);
                    for(int c = 0; c < row.size(); c++)
                    {
                        XUINode cellNode = new XUINodeImpl("Cell");
                        cellNode.setLevel(cellLevel);
                        cellNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                        cellNode.setCDATA((String)row.get(c));
                        cellNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "justified", "justified",
                            "xs:token", "left");
                    }
                }


            } catch(Exception e)
            {
                throw new XUITypeFormatException(e.getMessage());
            }
        }
    }

    /**
     * <p>Sets the table data as a 2 dimensional list (list of lists). This is the same as the previous method
     * with the added feature of being able to specify the alignment. For alignment options, see XUIUtil.</p>
     *
     * <p>The above creates a table that is 2 rows and 3 columns.</p>
     *
     * @param data the 2 dimensional list (list of lists) that contain string data in it.
     * @param headers the headers that are placed at the tops of the columns.
     * @throws org.purnamaproject.xui.XUITypeFormatException if any of the lists are null, if any of the strings are null, if
     * any of the lists are not the same size as specified row and column size as what was specified
     * for this table.
     * @see #setTableData(Vector, Vector)
     */
    public void setTableData(Vector data, Vector headers, int alignment) throws XUITypeFormatException
    {
        if(data == null)
            throw new XUITypeFormatException("The data list must not be null.");
        else if(data.size() == 0)
            throw new XUITypeFormatException("The data list contain other Vectors.");
        if(headers == null)
            throw new XUITypeFormatException("The data list must not be null.");
        else if(headers.size() != data.size())
            throw new XUITypeFormatException("The header list must be the same size as the data list.");
        else if(alignment != XUIUtils.LEFT_JUSTIFIED || alignment != XUIUtils.RIGHT_JUSTIFIED ||
            alignment != XUIUtils.CENTER_JUSTIFIED)
            throw new XUITypeFormatException("The alignment must be either 'left' 'right' or 'center'.");
        else
        {
            DefaultTableModel model = (DefaultTableModel)table.getModel();
            try
            {
                model.setDataVector(data, headers);
                table.invalidate();
                if(table.getParent() != null)
                    table.getParent().validate();

                // add the headers
                XUINode headerNode = new XUINodeImpl("ColumnHeader");
                headerNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                int level = tableNode.getLevel();
                level += 1;
                headerNode.setLevel(level);
                level += 1;
                for(int h = 0; h < headers.size(); h++)
                {
                    XUINode cellNode = new XUINodeImpl("Cell");
                    cellNode.setLevel(level);
                    cellNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                    cellNode.setCDATA((String)headers.get(h));
                    headerNode.addChildNode(cellNode);
                }
                tableNode.addChildNode(headerNode);

                // get the alignment ready
                String align = "left";
                if(alignment == XUIUtils.RIGHT_JUSTIFIED)
                    align = "right";
                else if(alignment == XUIUtils.CENTER_JUSTIFIED)
                    align = "center";

                // set the level for the rows
                level -= 1;
                int cellLevel = level + 1;

                // now the data cells
                for(int r = 0; r < data.size(); r++)
                {
                    // new row
                    XUINode rowNode = new XUINodeImpl("Row");
                    rowNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                    rowNode.setLevel(level);
                    Vector row = (Vector)data.get(r);
                    for(int c = 0; c < row.size(); c++)
                    {
                        XUINode cellNode = new XUINodeImpl("Cell");
                        cellNode.setLevel(cellLevel);
                        cellNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                        cellNode.setCDATA((String)row.get(c));
                        cellNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "justified", "justified",
                            "xs:token", align);
                    }
                }


            } catch(Exception e)
            {
                throw new XUITypeFormatException(e.getMessage());
            }
        }
    }

    /**
     * Adds a new row to the current table data. The new row is appended at the bottom.
     *
     * @param data the data vector to add. The data must have the same number of columns
     * as the current table or an exception is generated.
     * @param alignment the alignment for the row.
     * @throws org.purnamaproject.xui.XUITypeFormatException if the number of entries in this new row is not the
     * the same number of columns found in the current table.
     */
    public void addRow(Vector data, int alignment) throws XUITypeFormatException
    {
        int align;
        if(data == null)
            throw new XUITypeFormatException("The data list must not be null.");
        else if(alignment != XUIUtils.LEFT_JUSTIFIED)
            align = JLabel.LEFT;
        else if(alignment != XUIUtils.RIGHT_JUSTIFIED)
            align = JLabel.RIGHT;
        else if(alignment != XUIUtils.CENTER_JUSTIFIED)
            align = JLabel.CENTER;
        else
        {
            throw new XUITypeFormatException("Alignment must be either left, right or justified.");
        }
        try
        {
            DefaultTableModel model = (DefaultTableModel)table.getModel();
            model.addRow(data);

            // add to the DOM too ...
            XUINode rowNode = new XUINodeImpl("Row");
            rowNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
            int level = tableNode.getLevel();
            ++level;
            rowNode.setLevel(level);
            tableNode.addChildNode(rowNode);


            for(int x = 0; x < data.size(); x++)
            {
                JLabel renderer = (JLabel)table.getColumnModel().getColumn(x).getCellRenderer();
                renderer.setHorizontalAlignment(align);
                XUINode cellNode = new XUINodeImpl("Cell");
                cellNode.setCDATA((String)data.get(x));
                cellNode.setLevel(++level);
                cellNode.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                cellNode.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "justified", "justified", "xs:string",
                    "left");
                rowNode.addChildNode(cellNode);
            }



        }catch(Exception e)
        {
            throw new XUITypeFormatException(e.getMessage());
        }
    }

    /**
     * Removes the row based on the row index. If the index is out of bounds, then an
     * out of bounds exception will be generated.
     *
     * @param rowNumber the row number to remove.
     */
    public void removeRow(int rowNumber)
    {
        DefaultTableModel model = (DefaultTableModel)table.getModel();
        int rows = model.getRowCount();
        if(rowNumber > rows)
            throw new XUITypeFormatException("The row number to remove is greater than the number of rows.");
        else
        {
            model.removeRow(rowNumber);
            table.invalidate();
            if(table.getParent() != null)
                table.getParent().validate();
            List rowNodes = tableNode.getChildNodesByName("Row");
            rowNodes.remove(rowNumber);
        }
    }

    /**
     * Adds a new column to the current table data. The new column is appended at the
     * the end (right side). New data is appended at the end of the table. The cells in the
     * new column will use the alignment from the cells in the same row.
     *
     * @param columnName the label or name of the new column. String cannot be null.
     * @throws org.purnamaproject.xui.XUITypeFormatException if the number of column name is null.
     */
    public void addColumn(String columnName, Vector data) throws XUITypeFormatException
    {
        DefaultTableModel model = (DefaultTableModel)table.getModel();
        if(columnName == null)
            throw new XUITypeFormatException("The column name cannot be null.");
        else
        {
            model.addColumn(columnName, data);
            if(table.getParent() != null)
                table.getParent().validate();
            List rowNodes = tableNode.getChildNodesByName("Row");
            try
            {
                for(int n = 0; n < rowNodes.size(); n++)
                {
                    XUINode rowNode = (XUINode)rowNodes.get(n);
                    // get the alignment for the previous column
                    String alignment = "left";
                    if(n > 0)
                    {
                        XUINode previousCell = (XUINode)rowNodes.get((n-1));
                        alignment = previousCell.getAttributeValue("justified");
                    }

                    XUINode newCell = new XUINodeImpl("Cell");
                    newCell.addAttribute("http://xml.bcit.ca/PurnamaProject/2003/xui", "justified", "justified",
                        "xs:token", alignment);

                    JLabel renderer = (JLabel)table.getCellRenderer(n, (table.getColumnCount() -1));

                    if(alignment.equals("left"))
                        renderer.setHorizontalAlignment(JLabel.LEFT);
                    else if(alignment.equals("right"))
                        renderer.setHorizontalAlignment(JLabel.RIGHT);
                    else if(alignment.equals("center"))
                        renderer.setHorizontalAlignment(JLabel.CENTER);


                    int level = rowNode.getLevel();
                    newCell.setLevel(++level);
                    newCell.setCDATA((String)data.get(n));
                    newCell.addNamespace("xui", "http://xml.bcit.ca/PurnamaProject/2003/xui");
                    rowNode.addChildNode(newCell);
                }
            }catch(Exception e)
            {
                throw new XUITypeFormatException(e.getMessage());
            }
        }

    }

    /**
     * Removes the column based on the column index. If the index is out of bounds, then an
     * out of bounds exception will be generated.
     *
     * @param columnNumber the column number to remove.
     */
    public void removeColumn(int columnNumber)
    {
        DefaultTableModel model = (DefaultTableModel)table.getModel();
        int columns = model.getColumnCount();
        if(columnNumber > columns)
            throw new XUITypeFormatException("The column number to remove is greater than the number of columns.");
        else
        {
            table.removeColumn(table.getColumn(table.getColumnName(columnNumber)));
            table.invalidate();
            if(table.getParent() != null)
                table.getParent().validate();
            List rowNodes = tableNode.getChildNodesByName("Row");
            for(int i = 0; i < rowNodes.size(); i++)
            {
                XUINode row = (XUINode)rowNodes.get(i);
                List cells = row.getChildNodesByName("Cell");
                cells.remove(i);
            }
        }
    }

    /**
     * Handles the selection of a cell whether it's a double or single
     * click.
     *
     * @param e the event that was generated and that represents the selection
     * event.
     */
    public void mouseReleased(MouseEvent e)
    {
        if(e.getSource() == table)
        {
            int size = tableModelList.size();
            for(int i = 0; i < size; i++)
            {
                int column = table.columnAtPoint(e.getPoint());
                int row = table.rowAtPoint(e.getPoint());

                XUITableModel model = (XUITableModel)tableModelList.get(i);
                if (e.getClickCount() == 2)
                    model.tableCellEditingAction(this, row, column);
                else if(e.getClickCount() == 1)
                    model.tableCellSelectedAction(this, row, column);
            }
        }
    }

    /**
     * Generated event when something in the table has changed.
     */
    public void tableChanged(TableModelEvent e)
    {
        int size = tableModelList.size();
        for(int i = 0; i < size; i++)
        {

            XUITableModel model = (XUITableModel)tableModelList.get(i);

            int column = e.getColumn();
            int row = e.getLastRow();

            model.tableCellEditedAction(this, row, column);
        }
    }

    /**
     * Not used.
     */
    public void mouseClicked(MouseEvent e){}

    /**
     * Not used.
     */
    public void mousePressed(MouseEvent e){}

    /**
     * Not used.
     */
    public void mouseEntered(MouseEvent e){}

    /**
     * Not used.
     */
    public void mouseExited(MouseEvent e){}

    /**
     * Adds a new model to listen to the <code>XUIComponent</code> that also is a <code>XUIEventSource</code>.
     * If the model is not an instance of the ActionModel type, then no binding is done.
     *
     * @param model the model that listens to events based on this type.
     */
    public void addEventListener(XUIModel model)
    {
        if(model instanceof XUITableModel)
        {
            // call up the action model.
            tableModelList.add(model);
            table.addMouseListener(this);
            table.getModel().addTableModelListener(this);
        }
    }

    /**
     * Delete a model from the <code>XUIComponent</code> that also is a <code>XUIEventSource</code>.
     *
     * @param model the model that is to no longer be a listener.
     */
    public void removeEventListener(XUIModel model)
    {
        tableModelList.remove(model);
        table.removeMouseListener(this);
        table.getModel().removeTableModelListener(this);

    }

}
